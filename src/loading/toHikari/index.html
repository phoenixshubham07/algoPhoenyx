<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code-Driven Animation</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@900&display=swap');

        html, body {
            font-family: "Montserrat", sans-serif;
            font-optical-sizing: auto;
            font-weight: 900;
            font-style: normal;
            background: #000;
            overflow: hidden;
        }

        body, .pov { /* Combined body and pov */
            width: 100%;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0; /* Added to reset default body margin */
        }

        .pov { /* Specific pov styles if any (already covered by body, .pov) */
            /* perspective: 999px; */ /* Moved perspective to .die */
        }

        .tray {
            /* Height will be set by JS */
        }

        .die {
            width: 400px;
            height: 55px;
            padding-bottom: 9px;
            perspective: 999px;
        }

        .cube {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
        }

        .face {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            /* letter-spacing:-1px; */
            backface-visibility: hidden;
            /* overflow:hidden; */
        }
    </style>
</head>
<body>

    <div class="pov">
        <div class="tray">
            <div class="die">
                <div class="cube">
                    <div class="face" style="font-size:60px">algo</div>
                    <div class="face" style="font-size:58px">Amaterasu</div>
                    <div class="face" style="font-size:55px">Hikari</div>
                    <!-- The 4th face (rots[3]) is implicitly created by GSAP but not in HTML,
                         which might be why rots[3].a is 0.0 (invisible). 
                         The JS only selects 3 faces: rots[0], rots[1], rots[2] in the color animation.
                         Let's add a 4th face to match the rots array.
                    -->
                    <div class="face" style="font-size:55px"></div> 
                </div>
            </div>
            <!-- clones will go here -->
        </div>
    </div>

    <!-- Load GSAP library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <script>
        const n = 19;
        const rots = [
            { ry: 270, a: 0.5 },
            { ry: 0, a: 0.85 },
            { ry: 90, a: 0.4 },
            { ry: 180, a: 0.0 }
        ];

        // Set initial face positions
        gsap.set(".face", {
            z: 200,
            rotateY: i => rots[i].ry,
            transformOrigin: "50% 50% -201px"
        });

        for (let i = 0; i < n; i++) {
            let die = document.querySelector('.die');
            let cube = die.querySelector('.cube');

            if (i > 0) {
                let clone = document.querySelector('.die').cloneNode(true);
                document.querySelector('.tray').append(clone);
                cube = clone.querySelector('.cube');
            }

            // Select all faces *within this cube*
            let facesInThisCube = cube.querySelectorAll('.face');

            gsap.timeline({ repeat: -1, yoyo: true, defaults: { ease: 'power3.inOut', duration: 1 } })
                .fromTo(cube, {
                    rotateY: -90
                }, {
                    rotateY: 90,
                    ease: 'power1.inOut',
                    duration: 2
                })
                // Color animations
                // Note: The original code's color logic seems to target 3 faces, 
                // but there are 4 faces and 4 rots. This might be intentional.
                // We'll stick to the original logic which targets faces by index j.
                .fromTo(facesInThisCube, {
                    color: (j) => {
                        // Handle potential index out of bounds if j >= 3
                        let rotIndex = [3, 0, 1][j]; 
                        if (j >= 3) rotIndex = rots[3].a; // Default to last if index is weird
                        if (j === 3) rotIndex = 2; // explicit 4th face
                        let lightness = 100 * (rots[rotIndex]?.a || rots[3].a);
                        return 'hsl(' + (i / n * 75 + 130) + ', 67%,' + lightness + '%)';
                    }
                }, {
                    color: (j) => {
                        let rotIndex = [0, 1, 2][j];
                        if (j >= 3) rotIndex = rots[3].a;
                        if (j === 3) rotIndex = 3; // explicit 4th face
                        let lightness = 100 * (rots[rotIndex]?.a || rots[3].a);
                        return 'hsl(' + (i / n * 75 + 130) + ', 67%,' + lightness + '%)';
                    }
                }, 0)
                .to(facesInThisCube, {
                    color: (j) => {
                        let rotIndex = [1, 2, 3][j];
                        if (j >= 3) rotIndex = rots[3].a;
                        if (j === 3) rotIndex = 0; // explicit 4th face
                        let lightness = 100 * (rots[rotIndex]?.a || rots[3].a);
                        return 'hsl(' + (i / n * 75 + 130) + ', 67%,' + lightness + '%)';
                    }
                }, 1)
                .progress(i / n);
        }

        // Global tray animations
        gsap.timeline({ repeat: -1, yoyo: true, defaults: { ease: 'power1.inOut' } })
            .from('.tray', { yPercent: -3, duration: 2 }, 0)
            .fromTo('.tray', { rotate: -15 }, { rotate: 15, duration: 4 }, 0)
            .from('.die', { duration: 0.01, opacity: 0, stagger: { each: -0.05, ease: 'power1.in' } }, 0)
            .to('.tray', { scale: 1.2, duration: 2, ease: 'power3.inOut' }, 0);

        // Resize handler
        window.onload = window.onresize = () => {
            const h = n * 56;
            gsap.set('.tray', { height: h });
            // Scale the entire .pov container to fit the viewport height
            gsap.set('.pov', { scale: window.innerHeight / h });
        };
    </script>

</body>
</html>